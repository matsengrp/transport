## This script computes OT distances between the individual mouse repertoires
## in the IEL dataset and makes a dendrogram from the distance matrix
##
## It is run from the transport/ directory

import numpy as np
import matplotlib.pyplot as plt
import ot
from glob import glob
from os import popen, remove, system
from os.path import exists
import sys
import pandas as pd
import time

## this is the tcrdist-computing executable
exe = 'pubtcrs/bin/tcrdists'

## this is a db-directory needed for the tcrdists calc
db = 'data/mouse_db'

## this is the directory where the individual mouse tcrs files are
tcrs_dir = 'data/iels_tcrs_by_mouse/'

lambd = .01 # the sinkhorn regularization factor

Dmax = 200 # divide raw TCRdist values by this prior to sinkhorn calc


# this file is generated by step 1, read by step 2
step1_tsvfile = 'results/iels/ot_dists_iels.tsv'

# these are the names of the image files to be generated by step 2:
tree_pngfile = 'results/iels/IELrep_OT_mouse_trees.png'
single_tree_pngfile = 'results/iels/IELrep_OT_mouse_tree_beta.png'

def get_raw_distance_matrix( f1, f2 ):
    cmd = '{} -i {} -j {} -d {} --terse'.format( exe, f1, f2, db )
    #print(cmd)
    all_dists = []
    for line in popen(cmd):
        all_dists.append( [float(x) for x in line.split() ] )
    N1 = len(all_dists)
    N2 = len(all_dists[0])
    for dists in all_dists:
        assert len(dists) == N2
    D = np.array(all_dists)
    return D


## STEP 1 #######################
# compute the distances for use in step 2
dfl = []
for ab in 'AB':
    tcr_files = sorted( glob('{}*_{}.tcrs'.format(tcrs_dir,ab)) )

    for f1 in tcr_files:
        for f2 in tcr_files:
            if f2<f1:
                continue
            t0 = time.time()
            D = get_raw_distance_matrix( f1, f2 )
            tcrdist_time = time.time() - t0
            D /= Dmax
            N1,N2 = D.shape

            wts1 = np.ones((N1,)) / N1
            wts2 = np.ones((N2,)) / N2

            t0 = time.time()
            dist = ot.sinkhorn2(wts1, wts2, D, lambd)#, verbose=True)
            # in some versions it's a float, in others it's a list/array
            if type(dist) is list or type(dist) is np.ndarray:
                dist = dist[0]
            dist *= Dmax
            sinkhorn_time = time.time() - t0
            print(f'sinkhorn_dist: {dist:.3f} lambda: {lambd} Dmax: {Dmax} '
                  f'tcrdist_time: {tcrdist_time:.3f} sinkhorn_time: '
                  f'{sinkhorn_time:.3f} Ns: {N1} {N2} files: {f1} {f2}',
                  flush=True)
            dfl.append(dict(
                f1=f1,
                f2=f2,
                N1=N1,
                N2=N2,
                dist=dist,
                tcrdist_time=tcrdist_time,
                sinkhorn_time=sinkhorn_time,
            ))
            # save partial results
            pd.DataFrame(dfl).to_csv(step1_tsvfile, sep='\t', index=False)
pd.DataFrame(dfl).to_csv(step1_tsvfile, sep='\t', index=False)
print('made:', step1_tsvfile)


## STEP 2 #############
## load the distances from the TSV file generated by step 1
all_ots = { 'A': {}, 'B': {}, 'AB': {} }
all_tcr_counts = { 'A': {}, 'B': {} }
results = pd.read_table(step1_tsvfile)
for l in results.itertuples():
    ab = l.f1[-6] # A or B
    m1 = l.f1.split('/')[-1][:-7] # eg: "CD4_17"
    m2 = l.f2.split('/')[-1][:-7]
    all_ots[ab][(m1,m2)] = l.dist
    all_ots[ab][(m2,m1)] = l.dist
    all_tcr_counts[ab][m1] = l.N1
    all_tcr_counts[ab][m2] = l.N2

assert sorted(all_tcr_counts['A'].keys()) == sorted(all_tcr_counts['B'].keys())
all_tcr_counts['AB'] = {
    m:all_tcr_counts['A'][m]+all_tcr_counts['B'][m]
    for m in all_tcr_counts['A']
}
# define alpha+beta chain distances as just the sum of the alpha distance and
#  the beta distance
for m1_m2 in all_ots['A']:
    all_ots['AB'][m1_m2] = all_ots['A'][m1_m2] + all_ots['B'][m1_m2]

nrows = 3
ncols = 1

plt.figure(1,figsize=(8*ncols,8*nrows))

from scipy.cluster import hierarchy
from scipy.spatial import distance

plotno=0
save_info = {}
for ab in ['A','B','AB']: # alpha, beta, and alpha+beta OT repertoire distances
    plotno += 1
    ax = plt.subplot(nrows,ncols,plotno)

    mice = sorted( set( [x[0] for x in all_ots[ab] ] ) )

    N = len(mice)

    D = np.zeros( (N,N) )
    for i,m1 in enumerate(mice):
        for j,m2 in enumerate(mice):
            if i<=j:continue
            dist = all_ots[ab][(m1,m2)]
            D[i,j] = dist
            D[j,i] = dist

    Z = hierarchy.linkage( distance.squareform(D,force='tovector'), method='ward' )

    labels = [f'{m} (#={all_tcr_counts[ab][m]})' for m in mice]

    hierarchy.dendrogram( Z, ax=ax, orientation='right', labels = labels )
    plt.title('{} OT dendrogram'.format(ab))

    save_info[ab] = [Z, mice]

plt.suptitle("""Individual IELrep mouse repertoire comparisons by OT
A is alpha chain repertoire OT
B is beta chain repertoire OT
AB is alpha OT + beta OT""")
plt.subplots_adjust(top = 0.93, bottom = 0.03, hspace = 0.15 )
print('making:',tree_pngfile)
plt.savefig(tree_pngfile,dpi=150)


# just make a single tree, demo for figure
plt.figure(figsize=(8,8))
rep_color = {'CD4':'C0', 'CD8':'C1', 'DN':'C2'}
Z, mice = save_info['B']
hierarchy.dendrogram(Z, ax=plt.gca(), orientation='right', labels = mice,
                     link_color_func=lambda x:'gray')##AAAAAA')
#for ticklabel, tickcolor in zip(plt.gca().get_yticklabels(), colors):
for ticklabel in plt.gca().get_yticklabels():
    color = rep_color[ticklabel.get_text().split('_')[0]]
    print(ticklabel)
    #print(dir(ticklabel))
    #exit()
    ticklabel.set_color(color)


# locs, labels = plt.yticks()
# print(locs)
# print(labels)
# leaves = hierarchy.leaves_list(Z)
# labels = [mice[x] for x in leaves]
# colors = [rep_color[m.split('_')[0]] for m in labels]
# plt.yticks(range(len(labels)), labels)
# for ticklabel, tickcolor in zip(plt.gca().get_yticklabels(), colors):
#     ticklabel.set_color(tickcolor)
print('making:',single_tree_pngfile)
plt.tight_layout()
plt.savefig(single_tree_pngfile, dpi=150)

